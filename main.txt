#include <msp430.h> 
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

// Global variables
int adc[10] = {0}; //Sets up an array of 10 integers and zero's the values
int avg_adc = 0;

void LED(int green, int red); // LED turn on/off
void calibrate(void); // Function Calibrates Photoresistor
void setupADC(void); // Sets Up the ADC for Photoresistor
void sampleADC(void); // Samples Values for ADC
void init_uart(void); // Initializes UART

/**
 * main.c
 */
int main(void)
{
	WDTCTL = WDTPW | WDTHOLD;	// stop watchdog timer
	P1DIR |= 0x01; // GREEN LED (BIT 0)
	P1DIR |= 0x08; // RED LED (BIT 3)
	setupADC();
	__enable_interrupt();

	calibrate();

	while(1){

	}

	return 0;
}

void calibrate(void){
    unsigned int i;
    for(i = 0; i < 50; i++){
        LED(1,1);
        __delay_cycles(50000);
        LED(0,0);
        __delay_cycles(50000);
    }
    LED(1,1);
    int calibrate[10], calibrate_avg = 0;
    // This for loop will calibrate the sensor for a full 5 seconds
    sampleADC();
    for(i = 0; i < 10; i++){
        avg_adc += adc[i];
    }
    avg_adc /= 10;
    for(i = 0; i < 50; i++){
        LED(0,0);
        __delay_cycles(50000);
        LED(1,1);
        __delay_cycles(50000);
    }
    LED(0,0);
}

void LED(int green, int red){
    if(green){
        P1OUT |= 0x01;
    } else {
        P1OUT &= ~0x01;
    }

    if(red){
        P1OUT |= 0x08;
    } else {
        P1OUT &= ~0x08;
    }

}

void setupADC(void){
    ADC10CTL1 = CONSEQ_2 + INCH_0;                      // Repeat single channel, A0
    ADC10CTL0 = ADC10SHT_2 + MSC + ADC10ON + ADC10IE;   // Sample & Hold Time + ADC10 ON + Interrupt Enable
    ADC10DTC1 = 0x0A;                                   // 10 conversions
    ADC10AE0 |= 0x80;                                   // Port 1.7
}

void sampleADC(void){
    ADC10CTL0 &= ~ENC;              // Disable Conversion
    while (ADC10CTL1 & BUSY);       // Wait if ADC10 busy
    ADC10SA = (int)adc;             // Transfers data to next array (DTC auto increments address)
    ADC10CTL0 |= ENC + ADC10SC;     // Enable Conversion and conversion start
    __bis_SR_register(CPUOFF + GIE);// Low Power Mode 0, ADC10_ISR
}

void init_uart(void)
{
    P1SEL  = BIT1 + BIT2;   // P1.1 = RXD, P1.2 = TXD
    P1SEL2 = BIT1 + BIT2;   // P1.1 = RXD, P1.2 = TXD
    UCA0CTL1 |= UCSSEL_2;   // SMCLK
    UCA0BR0 = 104;          // see baud rate divider above
    UCA0BR1 = 0;
    UCA0MCTL = UCBRS0;      // modulation UCBRSx = 1
    UCA0CTL1 &= ~UCSWRST;   // ** initialize USCI state machine **
    IE2 |= UCA0TXIE;        // Enable USCI_A0 TX interrupt
}

// ADC10 interrupt service routine
#pragma vector=ADC10_VECTOR
__interrupt void ADC10_ISR (void)
{
    __bic_SR_register_on_exit(CPUOFF); // Return to active mode
}

// Timer A0 interrupt service routine
#pragma vector=TIMER0_A0_VECTOR
__interrupt void Timer_A(void)
{
  ADC10CTL0 = SREF_1 + ADC10SHT_2 + REFON + ADC10ON + ADC10IE;
  ADC10CTL0 |= ENC;                         // ADC10 enable set
}

